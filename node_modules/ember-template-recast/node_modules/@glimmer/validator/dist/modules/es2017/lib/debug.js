import { DEBUG } from '@glimmer/env';
export let beginTrackingTransaction;
export let endTrackingTransaction;
export let runInTrackingTransaction;
export let deprecateMutationsInTrackingTransaction;
export let resetTrackingTransaction;
export let setTrackingTransactionEnv;
export let assertTagNotConsumed;
export let markTagAsConsumed;
export let logTrackingStack;

if (DEBUG) {
  let CONSUMED_TAGS = null;
  let TRANSACTION_STACK = []; /////////

  let TRANSACTION_ENV = {
    assert(message) {
      throw new Error(message);
    },

    deprecate(message) {
      console.warn(message);
    },

    debugMessage(obj, keyName) {
      let objName;

      if (typeof obj === 'function') {
        objName = obj.name;
      } else if (typeof obj === 'object' && obj !== null) {
        let className = obj.constructor && obj.constructor.name || '(unknown class)';
        objName = `(an instance of ${className})`;
      } else if (obj === undefined) {
        objName = '(an unknown tag)';
      } else {
        objName = String(obj);
      }

      let dirtyString = keyName ? `\`${keyName}\` on \`${objName}\`` : `\`${objName}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }

  };

  setTrackingTransactionEnv = env => Object.assign(TRANSACTION_ENV, env);

  beginTrackingTransaction = (_debugLabel, deprecate = false) => {
    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();
    let debugLabel = _debugLabel || undefined;
    let parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] || null;
    TRANSACTION_STACK.push({
      parent,
      debugLabel,
      deprecate
    });
  };

  endTrackingTransaction = () => {
    if (TRANSACTION_STACK.length === 0) {
      throw new Error('attempted to close a tracking transaction, but one was not open');
    }

    TRANSACTION_STACK.pop();

    if (TRANSACTION_STACK.length === 0) {
      CONSUMED_TAGS = null;
    }
  };

  resetTrackingTransaction = () => {
    let stack = '';

    if (TRANSACTION_STACK.length > 0) {
      stack = logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);
    }

    TRANSACTION_STACK = [];
    CONSUMED_TAGS = null;
    return stack;
  };
  /**
   * Creates a global autotracking transaction. This will prevent any backflow
   * in any `track` calls within the transaction, even if they are not
   * externally consumed.
   *
   * `runInAutotrackingTransaction` can be called within itself, and it will add
   * onto the existing transaction if one exists.
   *
   * TODO: Only throw an error if the `track` is consumed.
   */


  runInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };
  /**
   * Switches to deprecating within an autotracking transaction, if one exists.
   * If `runInAutotrackingTransaction` is called within the callback of this
   * method, it switches back to throwing an error, allowing zebra-striping of
   * the types of errors that are thrown.
   *
   * Does not start an autotracking transaction.
   *
   * NOTE: For Ember usage only, in general you should assert that these
   * invariants are true.
   */


  deprecateMutationsInTrackingTransaction = (fn, debugLabel) => {
    beginTrackingTransaction(debugLabel, true);

    try {
      fn();
    } finally {
      endTrackingTransaction();
    }
  };

  let nthIndex = (str, pattern, n, startingPos = -1) => {
    let i = startingPos;

    while (n-- > 0 && i++ < str.length) {
      i = str.indexOf(pattern, i);
      if (i < 0) break;
    }

    return i;
  };

  let makeTrackingErrorMessage = (transaction, obj, keyName) => {
    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    message.push(`\`${String(keyName)}\` was first used:`);
    message.push(logTrackingStack(transaction));
    message.push(`Stack trace for the update:`);
    return message.join('\n\n');
  };

  logTrackingStack = transaction => {
    let trackingStack = [];
    let current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (current === undefined) return '';

    while (current) {
      if (current.debugLabel) {
        trackingStack.unshift(current.debugLabel);
      }

      current = current.parent;
    } // TODO: Use String.prototype.repeat here once we can drop support for IE11


    return trackingStack.map((label, index) => Array(2 * index + 1).join(' ') + label).join('\n');
  };

  markTagAsConsumed = _tag => {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    CONSUMED_TAGS.set(_tag, TRANSACTION_STACK[TRANSACTION_STACK.length - 1]); // We need to mark the tag and all of its subtags as consumed, so we need to
    // cast it and access its internals. In the future this shouldn't be necessary,
    // this is only for computed properties.

    let tag = _tag;

    if (tag.subtag) {
      markTagAsConsumed(tag.subtag);
    }

    if (tag.subtags) {
      tag.subtags.forEach(tag => markTagAsConsumed(tag));
    }
  };

  assertTagNotConsumed = (tag, obj, keyName) => {
    if (CONSUMED_TAGS === null) return;
    let transaction = CONSUMED_TAGS.get(tag);
    if (!transaction) return;
    let currentTransaction = TRANSACTION_STACK[TRANSACTION_STACK.length - 1];

    if (currentTransaction.deprecate) {
      TRANSACTION_ENV.deprecate(makeTrackingErrorMessage(transaction, obj, keyName));
    } else {
      // This hack makes the assertion message nicer, we can cut off the first
      // few lines of the stack trace and let users know where the actual error
      // occurred.
      try {
        TRANSACTION_ENV.assert(makeTrackingErrorMessage(transaction, obj, keyName));
      } catch (e) {
        if (e.stack) {
          let updateStackBegin = e.stack.indexOf('Stack trace for the update:');

          if (updateStackBegin !== -1) {
            let start = nthIndex(e.stack, '\n', 1, updateStackBegin);
            let end = nthIndex(e.stack, '\n', 4, updateStackBegin);
            e.stack = e.stack.substr(0, start) + e.stack.substr(end);
          }
        }

        throw e;
      }
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3ZhbGlkYXRvci9saWIvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBUyxLQUFULFFBQXNCLGNBQXRCO0FBRUEsT0FBTyxJQUFJLHdCQUFKO0FBR1AsT0FBTyxJQUFJLHNCQUFKO0FBQ1AsT0FBTyxJQUFJLHdCQUFKO0FBR1AsT0FBTyxJQUFJLHVDQUFKO0FBRVAsT0FBTyxJQUFJLHdCQUFKO0FBQ1AsT0FBTyxJQUFJLHlCQUFKO0FBUVAsT0FBTyxJQUFJLG9CQUFKO0FBSVAsT0FBTyxJQUFJLGlCQUFKO0FBRVAsT0FBTyxJQUFJLGdCQUFKOztBQVFQLElBQUksS0FBSixFQUFXO0FBQ1QsTUFBSSxhQUFhLEdBQXFDLElBQXREO0FBRUEsTUFBSSxpQkFBaUIsR0FBa0IsRUFBdkMsQ0FIUyxDQUtUOztBQUVBLE1BQUksZUFBZSxHQUFHO0FBQ3BCLElBQUEsTUFBTSxDQUFDLE9BQUQsRUFBZ0I7QUFDcEIsWUFBTSxJQUFJLEtBQUosQ0FBVSxPQUFWLENBQU47QUFDRCxLQUhtQjs7QUFLcEIsSUFBQSxTQUFTLENBQUMsT0FBRCxFQUFnQjtBQUN2QixNQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEsT0FBYjtBQUNELEtBUG1COztBQVNwQixJQUFBLFlBQVksQ0FBQyxHQUFELEVBQWdCLE9BQWhCLEVBQWdDO0FBQzFDLFVBQUksT0FBSjs7QUFFQSxVQUFJLE9BQU8sR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzdCLFFBQUEsT0FBTyxHQUFHLEdBQUcsQ0FBQyxJQUFkO0FBQ0QsT0FGRCxNQUVPLElBQUksT0FBTyxHQUFQLEtBQWUsUUFBZixJQUEyQixHQUFHLEtBQUssSUFBdkMsRUFBNkM7QUFDbEQsWUFBSSxTQUFTLEdBQUksR0FBRyxDQUFDLFdBQUosSUFBbUIsR0FBRyxDQUFDLFdBQUosQ0FBZ0IsSUFBcEMsSUFBNkMsaUJBQTdEO0FBRUEsUUFBQSxPQUFPLEdBQUcsbUJBQW1CLFNB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RCxFQUFjLEdBQWQsRUFBbUIsT0FBbkIsQ0FBL0M7QUFDRCxPQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVixZQUFJLENBQUMsQ0FBQyxLQUFOLEVBQWE7QUFDWCxjQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxLQUFGLENBQVEsT0FBUixDQUFnQiw2QkFBaEIsQ0FBdkI7O0FBRUEsY0FBSSxnQkFBZ0IsS0FBSyxDQUFDLENBQTFCLEVBQTZCO0FBQzNCLGdCQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUgsRUFBVSxJQUFWLEVBQWdCLENBQWhCLEVBQW1CLGdCQUFuQixDQUFwQjtBQUNBLGdCQUFJLEdBQUcsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUgsRUFBVSxJQUFWLEVBQWdCLENBQWhCLEVBQW1CLGdCQUFuQixDQUFsQjtBQUNBLFlBQUEsQ0FBQyxDQUFDLEtBQUYsR0FBVSxDQUFDLENBQUMsS0FBRixDQUFRLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLEtBQWxCLElBQTJCLENBQUMsQ0FBQyxLQUFGLENBQVEsTUFBUixDQUFlLEdBQWYsQ0FBckM7QUFDRDtBQUNGOztBQUVELGNBQU0sQ0FBTjtBQUNEO0FBQ0Y7QUFDRixHQS9CRDtBQWdDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRhZyB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmV4cG9ydCBsZXQgYmVnaW5UcmFja2luZ1RyYW5zYWN0aW9uOlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlLCBkZXByZWNhdGU/OiBib29sZWFuKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuZXhwb3J0IGxldCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb246XG4gIHwgdW5kZWZpbmVkXG4gIHwgKChmbjogKCkgPT4gdm9pZCwgZGVidWdnaW5nQ29udGV4dD86IHN0cmluZyB8IGZhbHNlKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgZGVwcmVjYXRlTXV0YXRpb25zSW5UcmFja2luZ1RyYW5zYWN0aW9uOiB1bmRlZmluZWQgfCAoKGZuOiAoKSA9PiB2b2lkKSA9PiB2b2lkKTtcblxuZXhwb3J0IGxldCByZXNldFRyYWNraW5nVHJhbnNhY3Rpb246IHVuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpO1xuZXhwb3J0IGxldCBzZXRUcmFja2luZ1RyYW5zYWN0aW9uRW52OlxuICB8IHVuZGVmaW5lZFxuICB8ICgoZW52OiB7XG4gICAgICBhc3NlcnQ/KG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQ7XG4gICAgICBkZXByZWNhdGU/KG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQ7XG4gICAgICBkZWJ1Z01lc3NhZ2U/KG9iaj86IHVua25vd24sIGtleU5hbWU/OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgfSkgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgYXNzZXJ0VGFnTm90Q29uc3VtZWQ6XG4gIHwgdW5kZWZpbmVkXG4gIHwgKDxUPih0YWc6IFRhZywgb2JqPzogVCwga2V5TmFtZT86IGtleW9mIFQgfCBzdHJpbmcgfCBzeW1ib2wpID0+IHZvaWQpO1xuXG5leHBvcnQgbGV0IG1hcmtUYWdBc0NvbnN1bWVkOiB1bmRlZmluZWQgfCAoKF90YWc6IFRhZykgPT4gdm9pZCk7XG5cbmV4cG9ydCBsZXQgbG9nVHJhY2tpbmdTdGFjazogdW5kZWZpbmVkIHwgKCh0cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiBzdHJpbmcpO1xuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xuICBwYXJlbnQ6IFRyYW5zYWN0aW9uIHwgbnVsbDtcbiAgZGVidWdMYWJlbD86IHN0cmluZztcbiAgZGVwcmVjYXRlOiBib29sZWFuO1xufVxuXG5pZiAoREVCVUcpIHtcbiAgbGV0IENPTlNVTUVEX1RBR1M6IFdlYWtNYXA8VGFnLCBUcmFuc2FjdGlvbj4gfCBudWxsID0gbnVsbDtcblxuICBsZXQgVFJBTlNBQ1RJT05fU1RBQ0s6IFRyYW5zYWN0aW9uW10gPSBbXTtcblxuICAvLy8vLy8vLy9cblxuICBsZXQgVFJBTlNBQ1RJT05fRU5WID0ge1xuICAgIGFzc2VydChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgZGVwcmVjYXRlKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH0sXG5cbiAgICBkZWJ1Z01lc3NhZ2Uob2JqPzogdW5rbm93biwga2V5TmFtZT86IHN0cmluZykge1xuICAgICAgbGV0IG9iak5hbWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iak5hbWUgPSBvYmoubmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnKHVua25vd24gY2xhc3MpJztcblxuICAgICAgICBvYmpOYW1lID0gYChhbiBpbnN0YW5jZSBvZiAke2NsYXNzTmFtZX0pYDtcbiAgICAgIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqTmFtZSA9ICcoYW4gdW5rbm93biB0YWcpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iak5hbWUgPSBTdHJpbmcob2JqKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRpcnR5U3RyaW5nID0ga2V5TmFtZSA/IGBcXGAke2tleU5hbWV9XFxgIG9uIFxcYCR7b2JqTmFtZX1cXGBgIDogYFxcYCR7b2JqTmFtZX1cXGBgO1xuXG4gICAgICByZXR1cm4gYFlvdSBhdHRlbXB0ZWQgdG8gdXBkYXRlICR7ZGlydHlTdHJpbmd9LCBidXQgaXQgaGFkIGFscmVhZHkgYmVlbiB1c2VkIHByZXZpb3VzbHkgaW4gdGhlIHNhbWUgY29tcHV0YXRpb24uICBBdHRlbXB0aW5nIHRvIHVwZGF0ZSBhIHZhbHVlIGFmdGVyIHVzaW5nIGl0IGluIGEgY29tcHV0YXRpb24gY2FuIGNhdXNlIGxvZ2ljYWwgZXJyb3JzLCBpbmZpbml0ZSByZXZhbGlkYXRpb24gYnVncywgYW5kIHBlcmZvcm1hbmNlIGlzc3VlcywgYW5kIGlzIG5vdCBzdXBwb3J0ZWQuYDtcbiAgICB9LFxuICB9O1xuXG4gIHNldFRyYWNraW5nVHJhbnNhY3Rpb25FbnYgPSAoZW52KSA9PiBPYmplY3QuYXNzaWduKFRSQU5TQUNUSU9OX0VOViwgZW52KTtcblxuICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24gPSAoX2RlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSwgZGVwcmVjYXRlID0gZmFsc2UpID0+IHtcbiAgICBDT05TVU1FRF9UQUdTID0gQ09OU1VNRURfVEFHUyB8fCBuZXcgV2Vha01hcCgpO1xuXG4gICAgbGV0IGRlYnVnTGFiZWwgPSBfZGVidWdMYWJlbCB8fCB1bmRlZmluZWQ7XG5cbiAgICBsZXQgcGFyZW50ID0gVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0gfHwgbnVsbDtcblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLLnB1c2goe1xuICAgICAgcGFyZW50LFxuICAgICAgZGVidWdMYWJlbCxcbiAgICAgIGRlcHJlY2F0ZSxcbiAgICB9KTtcbiAgfTtcblxuICBlbmRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGlmIChUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIGNsb3NlIGEgdHJhY2tpbmcgdHJhbnNhY3Rpb24sIGJ1dCBvbmUgd2FzIG5vdCBvcGVuJyk7XG4gICAgfVxuXG4gICAgVFJBTlNBQ1RJT05fU1RBQ0sucG9wKCk7XG5cbiAgICBpZiAoVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoID09PSAwKSB7XG4gICAgICBDT05TVU1FRF9UQUdTID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmVzZXRUcmFja2luZ1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgIGxldCBzdGFjayA9ICcnO1xuXG4gICAgaWYgKFRSQU5TQUNUSU9OX1NUQUNLLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrID0gbG9nVHJhY2tpbmdTdGFjayEoVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV0pO1xuICAgIH1cblxuICAgIFRSQU5TQUNUSU9OX1NUQUNLID0gW107XG4gICAgQ09OU1VNRURfVEFHUyA9IG51bGw7XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBnbG9iYWwgYXV0b3RyYWNraW5nIHRyYW5zYWN0aW9uLiBUaGlzIHdpbGwgcHJldmVudCBhbnkgYmFja2Zsb3dcbiAgICogaW4gYW55IGB0cmFja2AgY2FsbHMgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiwgZXZlbiBpZiB0aGV5IGFyZSBub3RcbiAgICogZXh0ZXJuYWxseSBjb25zdW1lZC5cbiAgICpcbiAgICogYHJ1bkluQXV0b3RyYWNraW5nVHJhbnNhY3Rpb25gIGNhbiBiZSBjYWxsZWQgd2l0aGluIGl0c2VsZiwgYW5kIGl0IHdpbGwgYWRkXG4gICAqIG9udG8gdGhlIGV4aXN0aW5nIHRyYW5zYWN0aW9uIGlmIG9uZSBleGlzdHMuXG4gICAqXG4gICAqIFRPRE86IE9ubHkgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGB0cmFja2AgaXMgY29uc3VtZWQuXG4gICAqL1xuICBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gPSAoZm46ICgpID0+IHZvaWQsIGRlYnVnTGFiZWw/OiBzdHJpbmcgfCBmYWxzZSkgPT4ge1xuICAgIGJlZ2luVHJhY2tpbmdUcmFuc2FjdGlvbiEoZGVidWdMYWJlbCk7XG5cbiAgICB0cnkge1xuICAgICAgZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kVHJhY2tpbmdUcmFuc2FjdGlvbiEoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRvIGRlcHJlY2F0aW5nIHdpdGhpbiBhbiBhdXRvdHJhY2tpbmcgdHJhbnNhY3Rpb24sIGlmIG9uZSBleGlzdHMuXG4gICAqIElmIGBydW5JbkF1dG90cmFja2luZ1RyYW5zYWN0aW9uYCBpcyBjYWxsZWQgd2l0aGluIHRoZSBjYWxsYmFjayBvZiB0aGlzXG4gICAqIG1ldGhvZCwgaXQgc3dpdGNoZXMgYmFjayB0byB0aHJvd2luZyBhbiBlcnJvciwgYWxsb3dpbmcgemVicmEtc3RyaXBpbmcgb2ZcbiAgICogdGhlIHR5cGVzIG9mIGVycm9ycyB0aGF0IGFyZSB0aHJvd24uXG4gICAqXG4gICAqIERvZXMgbm90IHN0YXJ0IGFuIGF1dG90cmFja2luZyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogTk9URTogRm9yIEVtYmVyIHVzYWdlIG9ubHksIGluIGdlbmVyYWwgeW91IHNob3VsZCBhc3NlcnQgdGhhdCB0aGVzZVxuICAgKiBpbnZhcmlhbnRzIGFyZSB0cnVlLlxuICAgKi9cbiAgZGVwcmVjYXRlTXV0YXRpb25zSW5UcmFja2luZ1RyYW5zYWN0aW9uID0gKGZuOiAoKSA9PiB2b2lkLCBkZWJ1Z0xhYmVsPzogc3RyaW5nIHwgZmFsc2UpID0+IHtcbiAgICBiZWdpblRyYWNraW5nVHJhbnNhY3Rpb24hKGRlYnVnTGFiZWwsIHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZFRyYWNraW5nVHJhbnNhY3Rpb24hKCk7XG4gICAgfVxuICB9O1xuXG4gIGxldCBudGhJbmRleCA9IChzdHI6IHN0cmluZywgcGF0dGVybjogc3RyaW5nLCBuOiBudW1iZXIsIHN0YXJ0aW5nUG9zID0gLTEpID0+IHtcbiAgICBsZXQgaSA9IHN0YXJ0aW5nUG9zO1xuXG4gICAgd2hpbGUgKG4tLSA+IDAgJiYgaSsrIDwgc3RyLmxlbmd0aCkge1xuICAgICAgaSA9IHN0ci5pbmRleE9mKHBhdHRlcm4sIGkpO1xuICAgICAgaWYgKGkgPCAwKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBsZXQgbWFrZVRyYWNraW5nRXJyb3JNZXNzYWdlID0gPFQ+KFxuICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbixcbiAgICBvYmo/OiBULFxuICAgIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sXG4gICkgPT4ge1xuICAgIGxldCBtZXNzYWdlID0gW1RSQU5TQUNUSU9OX0VOVi5kZWJ1Z01lc3NhZ2Uob2JqLCBrZXlOYW1lICYmIFN0cmluZyhrZXlOYW1lKSldO1xuXG4gICAgbWVzc2FnZS5wdXNoKGBcXGAke1N0cmluZyhrZXlOYW1lKX1cXGAgd2FzIGZpcnN0IHVzZWQ6YCk7XG5cbiAgICBtZXNzYWdlLnB1c2gobG9nVHJhY2tpbmdTdGFjayEodHJhbnNhY3Rpb24pKTtcblxuICAgIG1lc3NhZ2UucHVzaChgU3RhY2sgdHJhY2UgZm9yIHRoZSB1cGRhdGU6YCk7XG5cbiAgICByZXR1cm4gbWVzc2FnZS5qb2luKCdcXG5cXG4nKTtcbiAgfTtcblxuICBsb2dUcmFja2luZ1N0YWNrID0gKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IHtcbiAgICBsZXQgdHJhY2tpbmdTdGFjayA9IFtdO1xuICAgIGxldCBjdXJyZW50OiBUcmFuc2FjdGlvbiB8IG51bGwgfCB1bmRlZmluZWQgPVxuICAgICAgdHJhbnNhY3Rpb24gfHwgVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGN1cnJlbnQuZGVidWdMYWJlbCkge1xuICAgICAgICB0cmFja2luZ1N0YWNrLnVuc2hpZnQoY3VycmVudC5kZWJ1Z0xhYmVsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCBoZXJlIG9uY2Ugd2UgY2FuIGRyb3Agc3VwcG9ydCBmb3IgSUUxMVxuICAgIHJldHVybiB0cmFja2luZ1N0YWNrLm1hcCgobGFiZWwsIGluZGV4KSA9PiBBcnJheSgyICogaW5kZXggKyAxKS5qb2luKCcgJykgKyBsYWJlbCkuam9pbignXFxuJyk7XG4gIH07XG5cbiAgbWFya1RhZ0FzQ29uc3VtZWQgPSAoX3RhZzogVGFnKSA9PiB7XG4gICAgaWYgKCFDT05TVU1FRF9UQUdTIHx8IENPTlNVTUVEX1RBR1MuaGFzKF90YWcpKSByZXR1cm47XG5cbiAgICBDT05TVU1FRF9UQUdTLnNldChfdGFnLCBUUkFOU0FDVElPTl9TVEFDS1tUUkFOU0FDVElPTl9TVEFDSy5sZW5ndGggLSAxXSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIG1hcmsgdGhlIHRhZyBhbmQgYWxsIG9mIGl0cyBzdWJ0YWdzIGFzIGNvbnN1bWVkLCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gY2FzdCBpdCBhbmQgYWNjZXNzIGl0cyBpbnRlcm5hbHMuIEluIHRoZSBmdXR1cmUgdGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LFxuICAgIC8vIHRoaXMgaXMgb25seSBmb3IgY29tcHV0ZWQgcHJvcGVydGllcy5cbiAgICBsZXQgdGFnID0gX3RhZyBhcyBhbnk7XG5cbiAgICBpZiAodGFnLnN1YnRhZykge1xuICAgICAgbWFya1RhZ0FzQ29uc3VtZWQhKHRhZy5zdWJ0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWcuc3VidGFncykge1xuICAgICAgdGFnLnN1YnRhZ3MuZm9yRWFjaCgodGFnOiBUYWcpID0+IG1hcmtUYWdBc0NvbnN1bWVkISh0YWcpKTtcbiAgICB9XG4gIH07XG5cbiAgYXNzZXJ0VGFnTm90Q29uc3VtZWQgPSA8VD4odGFnOiBUYWcsIG9iaj86IFQsIGtleU5hbWU/OiBrZXlvZiBUIHwgc3RyaW5nIHwgc3ltYm9sKSA9PiB7XG4gICAgaWYgKENPTlNVTUVEX1RBR1MgPT09IG51bGwpIHJldHVybjtcblxuICAgIGxldCB0cmFuc2FjdGlvbiA9IENPTlNVTUVEX1RBR1MuZ2V0KHRhZyk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSByZXR1cm47XG5cbiAgICBsZXQgY3VycmVudFRyYW5zYWN0aW9uID0gVFJBTlNBQ1RJT05fU1RBQ0tbVFJBTlNBQ1RJT05fU1RBQ0subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudFRyYW5zYWN0aW9uLmRlcHJlY2F0ZSkge1xuICAgICAgVFJBTlNBQ1RJT05fRU5WLmRlcHJlY2F0ZShtYWtlVHJhY2tpbmdFcnJvck1lc3NhZ2UodHJhbnNhY3Rpb24sIG9iaiwga2V5TmFtZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGhhY2sgbWFrZXMgdGhlIGFzc2VydGlvbiBtZXNzYWdlIG5pY2VyLCB3ZSBjYW4gY3V0IG9mZiB0aGUgZmlyc3RcbiAgICAgIC8vIGZldyBsaW5lcyBvZiB0aGUgc3RhY2sgdHJhY2UgYW5kIGxldCB1c2VycyBrbm93IHdoZXJlIHRoZSBhY3R1YWwgZXJyb3JcbiAgICAgIC8vIG9jY3VycmVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgVFJBTlNBQ1RJT05fRU5WLmFzc2VydChtYWtlVHJhY2tpbmdFcnJvck1lc3NhZ2UodHJhbnNhY3Rpb24sIG9iaiwga2V5TmFtZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgIGxldCB1cGRhdGVTdGFja0JlZ2luID0gZS5zdGFjay5pbmRleE9mKCdTdGFjayB0cmFjZSBmb3IgdGhlIHVwZGF0ZTonKTtcblxuICAgICAgICAgIGlmICh1cGRhdGVTdGFja0JlZ2luICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbnRoSW5kZXgoZS5zdGFjaywgJ1xcbicsIDEsIHVwZGF0ZVN0YWNrQmVnaW4pO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG50aEluZGV4KGUuc3RhY2ssICdcXG4nLCA0LCB1cGRhdGVTdGFja0JlZ2luKTtcbiAgICAgICAgICAgIGUuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cigwLCBzdGFydCkgKyBlLnN0YWNrLnN1YnN0cihlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==